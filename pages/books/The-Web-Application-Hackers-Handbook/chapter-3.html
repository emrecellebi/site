<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<link rel="stylesheet" type="text/css" href="css/doc.css">
	<title>Bölüm 3 - Web Uygulama Teknolojileri</title>
</head>
<body>
	<h1>Web Uygulama Teknolojileri</h1>
	<p>Web uygulamaları, işlevselliğini uygulamak için bir dizi teknoloji kullanır. Bu bölüm, web uygulamalarını hedef alırken 
	karşılaşabileceğiniz temel teknolojilere kısa bir giriş niteliğindedir. HTTP protokolünü, sunucu ve istemci tarafında yaygın 
	olarak kullanılan teknolojileri ve verileri farklı durumlarda temsil etmek için kullanılan kodlama şemalarını inceleyeceğiz. 
	Bu teknolojiler genel olarak anlaşılması kolaydır ve etkili saldırılar yapabilmek için ilgili özelliklerini anlamak önemlidir.</p>
	
	<p>Web uygulamalarında kullanılan temel teknolojileri zaten biliyorsanız, bu bölümü gözden geçirerek yeni bir şey sunup sunmadığını 
	doğrulayabilirsiniz. Web uygulamalarının nasıl çalıştığını hala öğreniyorsanız, belirli güvenlik açıkları hakkındaki sonraki 
	bölümlere devam etmeden önce bu bölümü okumanız önerilir. Konuların birçoğuyla ilgili daha fazla okuma için David Gourley ve Brian 
	Totty'nin "HTTP: The Definitive Guide" kitabını (O'Reilly, 2002) ve Dünya Çapında Ağ Konsorsiyumu'nun www.w3.org web sitesini öneririz.</p>
	
	<h2>HTTP Protokolü</h2>
	<p>Hypertext Transfer Protocol (HTTP), World Wide Web'e erişmek için kullanılan temel iletişim protokolüdür ve günümüzün tüm web 
	uygulamaları tarafından kullanılmaktadır. Başlangıçta statik metin tabanlı kaynakları almak için geliştirilmiş basit bir protokoldür. 
	O zamandan bu yana, günümüzde yaygın olan karmaşık dağıtık uygulamaları destekleyebilmesi için çeşitli şekillerde genişletilmiş ve 
	güçlendirilmiştir.</p>
	
	<p>HTTP, bir istemcinin bir istek mesajı gönderdiği ve sunucunun bir yanıt mesajı döndürdüğü mesaj tabanlı bir model kullanır. 
	Protokol esasen bağlantısızdır: HTTP aktarım mekanizması olarak durum bilgisi içeren TCP protokolünü kullansa da, her istek ve 
	yanıt alışverişi özel bir işlemdir ve farklı bir TCP bağlantısı kullanabilir.</p>
	
	<h2>HTTP Request</h2>
	<p>Tüm HTTP mesajları (request ve response), her biri ayrı bir satırda bulunan bir veya daha fazla başlıktan, ardından zorunlu bir 
	boş satırdan ve ardından isteğe bağlı bir mesaj gövdesinden oluşur. Tipik bir HTTP isteği aşağıdaki gibidir:</p>
	
	<dl>
		<dt><code>GET /auth/488/YourDetails.ashx?uid=129 HTTP/1.1</code></dt>
		<dt><code>Accept: application/x-ms-application, image/jpeg, application/xaml+xml,</code></dt>
		<dt><code>image/gif, image/pjpeg, application/x-ms-xbap, application/x-shockwaveflash, */*</code></dt>
		<dt><code>Referer: https://mdsec.net/auth/488/Home.ashx</code></dt>
		<dt><code>Accept-Language: en-GB</code></dt>
		<dt><code>User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64;</code></dt>
		<dt><code>Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR</code></dt>
		<dt><code>3.0.30729; .NET4.0C; InfoPath.3; .NET4.0E; FDM; .NET CLR 1.1.4322)</code></dt>
		<dt><code>Accept-Encoding: gzip, deflate</code></dt>
		<dt><code>Host: mdsec.net</code></dt>
		<dt><code>Connection: Keep-Alive</code></dt>
		<dt><code>Cookie: SessionId=5B70C71F3FD4968935CDB6682E545476</code></dt>
	</dl>
	
	<p>Her HTTP isteğinin ilk satırı, boşluklarla ayrılmış üç öğeden oluşur:</p>
	
	<ul>
		<li>HTTP yöntemini belirten bir fiil. En yaygın kullanılan yöntem, işlevi web sunucusundan bir kaynağı almak olan <code>GET</code> yöntemidir. 
		<code>GET</code> isteklerinin bir mesaj gövdesi yoktur, bu nedenle mesaj başlıklarından sonraki boş satırdan sonra başka veri gelmez</li>
		<li>URL tipik olarak, istemcinin bu kaynağa aktardığı parametreleri içeren isteğe bağlı bir sorgu dizesiyle birlikte istenen kaynak 
		için bir ad işlevi görür. Sorgu dizesi URL'deki <code>?</code> karakteri tarafından gösterilir. Örnek, <code>uid</code> adında ve <code>129</code> değerinde tek bir parametre içerir.</li>
		<li>İnternette yaygın olarak kullanılan HTTP sürümleri 1.0 ve 1.1'dir ve çoğu tarayıcı varsayılan olarak 1.1 sürümünü kullanır. Bu 
		iki sürümün özellikleri arasında birkaç fark vardır; ancak, web uygulamalarına saldırırken karşılaşmanız muhtemel tek fark, 1.1 
		sürümünde <code>host</code> request başlığının zorunlu olmasıdır.</li>
	</ul>
	
	<p>Örnek istekte dikkat çeken diğer bazı noktalar şunlardır:</p>
	
	<ul>
		<li><code>Referer</code> isteğin kaynaklandığı URL'yi belirtmek için kullanılır (örneğin, kullanıcı o sayfadaki bir bağlantıya tıkladığı için). 
		Bu başlığın orijinal HTTP spesifikasyonunda yanlış yazıldığını ve o zamandan beri yanlış yazılmış versiyonun korunduğunu unutmayın.</li>
		<li><code>User-Agent</code> isteği oluşturan tarayıcı veya diğer istemci yazılımı hakkında bilgi sağlamak için kullanılır. 
		Çoğu tarayıcının tarihsel nedenlerden dolayı Mozilla önekini içerdiğini unutmayın. Bu, başlangıçta baskın olan Netscape tarayıcısı 
		tarafından kullanılan <code>User-Agent</code> dizesiydi ve diğer tarayıcılar web sitelerine bu standartla uyumlu olduklarını 
		belirtmek istediler. Bilgisayar tarihindeki pek çok tuhaflıkta olduğu gibi, o kadar yerleşik hale geldi ki, örnekte gösterilen 
		isteği yapan Internet Explorer'ın mevcut sürümünde bile hala korunuyor.</li>
		<li><code>Host</code> erişilen tam URL'de görünen ana bilgisayar adını belirtir. Bu, aynı sunucuda birden fazla web sitesi barındırıldığında gereklidir, 
		çünkü isteğin ilk satırında gönderilen URL genellikle bir ana bilgisayar adı içermez. </li>
		<li><code>Çerez</code> sunucunun istemciye verdiği ek parametreleri göndermek için kullanılır.</li>
	</ul>
	
	<h2>HTTP Response</h2>
	<p>Tipik bir HTTP response şu şekildedir:</p>
	
	<dl>
		<dt><code>HTTP/1.1 200 OK</code></dt>
		<dt><code>Date: Tue, 19 Apr 2011 09:23:32 GMT</code></dt>
		<dt><code>Server: Microsoft-IIS/6.0</code></dt>
		<dt><code>X-Powered-By: ASP.NET</code></dt>
		<dt><code>Set-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc</code></dt>
		<dt><code>X-AspNet-Version: 2.0.50727</code></dt>
		<dt><code>Cache-Control: no-cache</code></dt>
		<dt><code>Pragma: no-cache</code></dt>
		<dt><code>Expires: Thu, 01 Jan 1970 00:00:00 GMT</code></dt>
		<dt><code>Content-Type: text/html; charset=utf-8</code></dt>
		<dt><code>Content-Length: 1067</code></dt>
		<br/>
		<dt><code>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://</code></dt>
		<dt><code>www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd”&gt;&lt;html xmlns=”http://</code></dt>
		<dt><code>www.w3.org/1999/xhtml” &gt;&lt;head&gt;&lt;title&gt;Your details&lt;/title&gt;</code></dt>
		<dt><code>...</code></dt>
	</dl>
	
	<p>Her HTTP response ilk satırı boşluklarla ayrılmış üç öğeden oluşur:</p>
	
	<ul>
		<li>Kullanılan HTTP sürümü.</li>
		<li>İsteğin sonucunu gösteren sayısal bir durum kodu. 200 en yaygın durum kodudur; isteğin başarılı olduğu ve istenen 
		kaynağın döndürüldüğü anlamına gelir.</li>
		<li>Yanıtın durumunu daha ayrıntılı olarak açıklayan metinsel bir "reason phrase". Bu herhangi bir değere sahip 
		olabilir ve mevcut tarayıcılar tarafından herhangi bir amaç için kullanılmaz</li>
	</ul>
	
	<p>Response dikkat çeken diğer bazı noktalar şunlardır:</p>
	
	<ul>
		<li><code>Server</code> kullanılan web sunucusu yazılımını ve bazen yüklü modüller ve sunucu işletim sistemi gibi diğer ayrıntıları 
		gösteren bir başlık içerir. İçerdiği bilgiler doğru olabilir veya olmayabilir.</li>
		<li><code>Set-Cookie</code> tarayıcıya bir çerez daha verir; bu, bu sunucuya yapılan sonraki isteklerin Cookie başlığında geri gönderilir.</li>
		<li><code>Pragma</code> tarayıcıya yanıtı önbelleğinde saklamaması talimatını verir. <code>Expires</code> yanıt içeriğinin geçmişte sona erdiğini ve bu 
		nedenle önbelleğe alınmaması gerektiğini belirtir. Bu talimatlar genellikle dinamik içerik döndürüldüğünde, tarayıcıların sonraki durumlarda bu 
		içeriğin yeni bir sürümünü almasını sağlamak için verilir.</li>
		<li>Neredeyse tüm HTTP response, başlıklardan sonraki boş satırı izleyen bir mesaj gövdesi içerir. <code>Content-Type</code> bu mesajın gövdesinin bir HTML belgesi içerdiğini belirtir.</li>
		<li>Content-Length mesaj gövdesinin bayt cinsinden uzunluğunu belirtir.</li>
	</ul>
	
	<h2>HTTP Methodları</h2>
	<p>Web uygulamalarına saldırırken, neredeyse yalnızca en yaygın kullanılan yöntemlerle uğraşacaksınız: <code>GET</code> ve <code>POST</code> Bu yöntemler arasındaki bazı önemli farkların farkında olmanız gerekir, 
	çünkü bunlar gözden kaçırılırsa bir uygulamanın güvenliğini etkileyebilir.</p>
	
	<p><code>GET</code> yöntemi kaynakları almak için tasarlanmıştır. Göndermek için kullanılabilir parametrelerini URL sorgu dizesinde istenen kaynağa ekler. Bu, kullanıcıların yeniden kullanabilecekleri dinamik bir 
	kaynak için URL'yi yer imlerine eklemelerini sağlar. Ya da diğer kullanıcılar eşdeğer kaynağı daha sonraki bir durumda (yer imli bir arama sorgusunda olduğu gibi) alabilirler. URL'ler ekranda görüntülenir ve tarayıcı 
	geçmişi ve web sunucusunun erişim günlükleri gibi çeşitli yerlerde kaydedilir. Ayrıca harici bağlantılar takip edildiğinde <code>Referer</code> başlığında diğer sitelere iletilirler. Bu nedenlerden dolayı, sorgu dizesi herhangi bir hassas bilgiyi iletmek için kullanılmamalıdır.</p>
	
	<p><code>POST</code> yöntemi eylemleri gerçekleştirmek için tasarlanmıştır. Bu yöntemle, istek parametreleri hem URL sorgu dizesinde hem de mesaj 
	gövdesinde gönderilebilir. URL yine de yer imine eklenebilir, ancak mesaj gövdesinde gönderilen tüm parametreler yer iminden çıkarılır. 
	Bu parametreler aynı zamanda URL günlüklerinin tutulduğu çeşitli konumlardan ve <code>Referer</code> başlığından da hariç tutulacaktır. <code>POST</code> 
	yöntemi eylemleri gerçekleştirmek için tasarlandığından, bir kullanıcı bu yöntem kullanılarak erişilen bir sayfaya geri dönmek 
	için tarayıcının Geri düğmesine tıklarsa, tarayıcı isteği otomatik olarak yeniden göndermez. Bunun yerine, Şekil 3-1'de gösterildiği 
	gibi, kullanıcıyı ne yapmak üzere olduğu konusunda uyarır. Bu, kullanıcıların farkında olmadan bir eylemi birden fazla kez 
	gerçekleştirmesini önler. Bu nedenle, bir eylem gerçekleştirilirken her zaman <code>POST</code> istekleri kullanılmalıdır.</p>
	
	<center>
		<img src="img/3.1.png" alt="">
		<p><b>Şekil 3.1</b> Tarayıcılar, kullanıcılar tarafından yapılan POST isteklerini otomatik olarak yeniden yayınlamaz, çünkü 
		bunlar bir eylemin birden fazla kez gerçekleştirilmesine neden olabilir</p>
	</center>
	
	<p><code>GET</code> ve <code>POST</code> yöntemlerine ek olarak, HTTP protokolü belirli amaçlar için oluşturulmuş çok sayıda başka yöntemi de destekler. 
	İşte büyük olasılıkla bilgi sahibi olmanız gereken diğer yöntemler:</p>
	
	<ul>
		<li><code>HEAD</code>, sunucunun yanıtında bir mesaj gövdesi döndürmemesi dışında <code>GET</code> isteği ile aynı şekilde çalışır. 
		Sunucu, ilgili GET isteğine döndüreceği başlıkların aynısını döndürmelidir. Dolayısıyla, bu yöntem bir kaynak için 
		<code>GET</code> isteği yapmadan önce o kaynağın mevcut olup olmadığını kontrol etmek için kullanılabilir.</li>
		<li><code>TRACE</code> tanılama amacıyla tasarlanmıştır. Sunucu, aldığı istek mesajının tam içeriğini yanıt gövdesinde döndürmelidir. Bu, 
		istemci ile sunucu arasında isteği değiştirebilecek herhangi bir proxy sunucusunun etkisini tespit etmek için kullanılabilir.</li>
		<li><code>OPTIONS</code>, sunucudan belirli bir kaynak için mevcut olan HTTP yöntemlerini bildirmesini ister. Sunucu genellikle mevcut 
		yöntemleri listeleyen bir <code>Allow</code> başlığı içeren bir yanıt döndürür.</li>
		<li><code>PUT</code>, isteğin gövdesinde bulunan içeriği kullanarak belirtilen kaynağı sunucuya yüklemeye çalışır. Bu yöntem etkinleştirilirse, 
		rastgele bir komut dosyası yükleyip sunucuda çalıştırmak gibi uygulamaya saldırmak için bu yöntemden yararlanabilirsiniz.</li>
	</ul>
	
	<p>Saldırıyla doğrudan ilgili olmayan başka birçok HTTP yöntemi mevcuttur web uygulamaları. Bununla birlikte, bir web sunucusu belirli durumlarda 
	kendisini saldırıya maruz bırakabilir tehlikeli yöntemler mevcuttur.</p>
	
	<h2>URL</h2>
	<p>Uniform Resource Locator (URL), bir web kaynağı için benzersiz bir tanımlayıcıdır bu kaynağın alınabileceği. Çoğu URL'nin biçimi aşağıdaki gibidir:</p>
	
	<code>protocol://hostname[:port]/[path/]file[?param=value]</code>
	
	<p>Bu şemadaki birkaç bileşen isteğe bağlıdır. Bağlantı noktası numarası genellikle yalnızca ilgili protokol tarafından kullanılan varsayılandan farklıysa 
	dahil edilir. Daha önce gösterilen HTTP isteğini oluşturmak için kullanılan URL aşağıdaki gibidir:</p>
	
	<code>https://mdsec.net/auth/488/YourDetails.ashx?uid=129</code>
	
	<p>Bu mutlak biçime ek olarak, URL'ler belirli bir URL'ye göreli olarak da belirtilebilir ana bilgisayara veya o ana bilgisayardaki belirli bir yola göre. Örneğin:</p>
	
	<dl>
		<dt><code>/auth/488/YourDetails.ashx?uid=129</code></dt>
		<dt><code>YourDetails.ashx?uid=129</code></dt>
	</dl>
	
	<p>Bu göreli formlar genellikle web sayfalarında gezinmeyi tanımlamak için kullanılır web sitesinin veya uygulamanın kendisi.</p>
	
	<p><b>NOT: URL yerine URI (Uniform Resource Identifier) teriminin kullanıldığını görebilirsiniz, ancak bu terim gerçekten 
	sadece resmi şartnamelerde ve bilgiçliklerini sergilemek isteyenler tarafından kullanılır</b></p>
	
	<h2>REST</h2>
	<p>Representational State Transfer (REST), dağıtık sistemler için bir mimari tarzıdır. isteklerin ve yanıtların mevcut durumun temsillerini içerdiği sistemler sistem 
	kaynaklarının durumu. Dünya'da kullanılan temel teknolojiler HTTP protokolü ve URL'lerin biçimi de dahil olmak üzere World Wide Web REST mimari tarzı.</p>
	
	<p>Sorgu dizesi içinde parametreler içeren URL'lerin kendileri REST kısıtlamalarına uygun olsa da, "REST-style URL" terimi genellikle aşağıdakileri belirtmek için kullanılır 
	yerine, parametrelerini URL dosya yolu içinde içeren bir URL sorgu dizesi. Örneğin, bir sorgu dizesi içeren aşağıdaki URL:</p>
	
	<code>http://wahh-app.com/search?make=ford&model=pinto</code>
	
	<p>"REST-style" parametreler içeren aşağıdaki URL'ye karşılık gelir:</p>
	
	<code>http://wahh-app.com/search/ford/pinto</code>
	
	<p>Bir uygulamanın içeriğini ve işlevselliğini eşlerken ve temel saldırı yüzeyini belirlerken bu farklı parametre stillerini nasıl göz önünde bulundurmanız gerektiği açıklanmaktadır.</p>
	
	<h2>HTTP Headers</h2>
	<p>HTTP, bazıları belirli olağandışı amaçlar için tasarlanmış olan çok sayıda başlığı destekler. Bazı başlıklar hem istekler hem de yanıtlar için kullanılabilirken, diğerleri bu mesaj 
	türlerinden birine özgüdür. Aşağıdaki bölümlerde web uygulamalarına saldırırken karşılaşmanız muhtemel başlıklar açıklanmaktadır.</p>
	
	<h2>Genel Header</h2>
	<ul>
		<li><code>Connection</code>, iletişimin diğer ucuna, HTTP iletimi tamamlandıktan sonra TCP bağlantısını kapatması veya başka mesajlar için açık tutması gerektiğini söyler.</li>
		<li><code>Content-Encoding</code>, mesaj gövdesinde bulunan içerik için ne tür bir kodlama kullanıldığını belirtir, örneğin bazı uygulamalar tarafından daha hızlı iletim için yanıtları sıkıştırmak için kullanılan <code>gzip</code> gibi.</li>
		<li><code>Content-Length</code> mesaj gövdesinin uzunluğunu bayt cinsinden belirtir (<code>HEAD</code> isteklerine verilen yanıtlarda, ilgili <code>GET</code> isteğine verilen yanıttaki gövdenin uzunluğunu belirtmesi durumu hariç).</li>
		<li><code>Content-Type</code>, HTML belgeleri için <code>text/html</code> gibi mesaj gövdesinde bulunan içeriğin türünü belirtir.</li>
		<li><code>Transfer-Encoding</code>, HTTP üzerinden aktarımını kolaylaştırmak için mesaj gövdesinde gerçekleştirilen herhangi bir kodlamayı belirtir. Normalde, bu kullanıldığında yığın kodlamayı belirtmek için kullanılır.</li>
	</ul>
	
	<h2>Request Headers</h2>
	<ul>
		<li><code>Accept</code>, sunucuya istemcinin ne tür içerikleri kabul etmeye istekli olduğunu bildirir, görüntü türleri, ofis belgesi biçimleri vb. gibi.</li>
		<li><code>Accept-Encoding</code>, sunucuya istemcinin ne tür içerik kodlamalarını kabul etmeye istekli olduğunu söyler</li>
		<li><code>Authorization</code>, yerleşik sistemlerden biri için kimlik bilgilerini sunucuya gönderir HTTP kimlik doğrulama türleri.</li>
		<li><code>Cookie</code>, sunucunun daha önce yayınladığı çerezleri sunucuya gönderir.</li>
		<li><code>Host</code>, istenen tam URL'de görünen ana bilgisayar adını belirtir</li>
		<li><code>If-Modified-Since</code>, tarayıcının istenen kaynağı en son ne zaman aldığını belirtir. Kaynak o zamandan beri değişmediyse, sunucu istemciye 304 durum kodlu 
		bir yanıt kullanarak önbelleğe alınmış kopyasını kullanmasını söyleyebilir.</li>
		<li><code>If-None-Match</code>, mesaj gövdesinin içeriğini belirten bir tanımlayıcı olan bir varlık etiketi belirtir. Tarayıcı, sunucunun istenen kaynakla birlikte en son alındığında yayınladığı varlık etiketini gönderir. 
		Sunucu, tarayıcının kaynağın önbelleğe alınmış kopyasını kullanıp kullanamayacağını belirlemek için varlık etiketini kullanabilir.</li>
		<li><code>Origin</code>, cross-domain Ajax isteklerinde isteğin kaynaklandığı alanı belirtmek için kullanılır</li>
		<li><code>Referer</code>, geçerli isteğin kaynaklandığı URL'yi belirtir</li>
		<li><code>User-Agent</code>, isteği oluşturan tarayıcı veya diğer istemci yazılımı hakkında bilgi sağlar.</li>
	</ul>
	
	<h2>Response Headers</h2>
	<ul>
		<li><code>Access-Control-Allow-Origin</code>, kaynağın etki alanları arası Ajax istekleri yoluyla alınıp alınamayacağını belirtir</li>
		<li><code>Cache-Control</code> passes caching directives to the browser (for example, <code>no-cache</code>).</li>
		<li><code>ETag</code> bir varlık etiketini belirtir. İstemciler, tarayıcının önbelleğinde kaynağın hangi sürümünü tuttuğunu sunucuya bildirmek için <code>If-None-Match</code> üstbilgisinde aynı kaynak için gelecekteki isteklerde bu tanımlayıcıyı gönderebilir.</li>
		<li><code>Expires</code>, tarayıcıya mesaj gövdesinin içeriğinin ne kadar süreyle geçerli olduğunu bildirir. Tarayıcı bu süreye kadar bu kaynağın önbelleğe alınmış kopyasını kullanabilir.</li>
		<li><code>Location</code>, yeniden yönlendirme yanıtlarında (3 ile başlayan bir durum koduna sahip olanlar) yönlendirmenin hedefini belirtmek için kullanılır.</li>
		<li><code>Pragma</code> önbellekleme yönergelerini tarayıcıya iletir (örneğin, <code>no-cache</code>)</li>
		<li><code>Server</code>, kullanılan web sunucusu yazılımı hakkında bilgi sağlar.</li>
		<li><code>Set-Cookie</code>, tarayıcıya sonraki isteklerde sunucuya geri göndereceği çerezler verir.</li>
		<li><code>WWW-Authenticate</code>, 401 durum koduna sahip yanıtlarda, sunucunun desteklediği kimlik doğrulama tür(ler)i hakkında ayrıntı sağlamak için kullanılır.</li>
		<li><code>X-Frame-Options</code>, geçerli yanıtın bir tarayıcı çerçevesi içinde yüklenip yüklenemeyeceğini ve nasıl yüklenebileceğini belirtir</li>
	</ul>
	
	<h2>Cookies</h2>
	<p>Çerezler, çoğu web uygulamasının dayandığı HTTP protokolünün önemli bir parçasıdır. Sıklıkla güvenlik açıklarından faydalanmak için bir araç olarak kullanılabilirler. Çerez mekanizması, sunucunun istemciye veri öğeleri göndermesini ve istemcinin bunları saklayıp sunucuya yeniden göndermesini sağlar. Diğer istek parametresi türlerinden (URL sorgu dizesi veya mesaj gövdesi içinde yer alanlar) farklı olarak, çerezler uygulama veya kullanıcı tarafından herhangi bir özel işlem gerektirmeden sonraki her istekte yeniden gönderilmeye devam eder.</p>
	
	<p>Bir sunucu, gördüğünüz gibi <code>Set-Cookie</code> yanıt başlığını kullanarak bir çerez yayınlar:</p>
	
	<code>Set-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc</code>
	
	<p>Kullanıcının tarayıcısı daha sonra otomatik olarak aşağıdaki başlığı ekler isteklerini aynı sunucuya geri gönderir:</p>
	
	<code>Cookie: tracking=tI8rk7joMx44S2Uu85nSWc</code>
	
	<p>Çerezler normalde gösterildiği gibi bir name/value çiftinden oluşur, ancak boşluk içermeyen herhangi bir dizeden de oluşabilir. Sunucunun yanıtında birden fazla <code>Set-Cookie</code> başlığı kullanılarak birden fazla çerez oluşturulabilir. Bunlar, farklı çerezleri ayıran bir noktalı virgül ile aynı <code>Cookie</code> başlığında sunucuya geri gönderilir.</p>
	<p>Çerezin gerçek değerine ek olarak, <code>Set-Cookie</code> başlığı, tarayıcının çerezi nasıl işleyeceğini kontrol etmek için kullanılabilecek aşağıdaki isteğe bağlı niteliklerden herhangi birini içerebilir:</p>

	<ul>
		<li><code>expires</code> — Çerezin geçerli olacağı bir tarih belirler. Bu, tarayıcının çerezi kalıcı depolama alanına kaydetmesine neden olur ve son kullanma tarihine ulaşılana kadar sonraki tarayıcı oturumlarında yeniden kullanılır. Bu özellik ayarlanmazsa, çerez yalnızca geçerli tarayıcı oturumunda kullanılır.</li>
		<li><code>domain</code> — Çerezin geçerli olduğu etki alanını belirtir. Bu, çerezin alındığı etki alanıyla aynı veya bir üst etki alanı olmalıdır.</li>
		<li><code>path</code> — Çerezin geçerli olduğu URL yolunu belirtir.</li>
		<li><code>secure</code> — Bu özellik ayarlanırsa, çerez yalnızca HTTPS isteklerinde gönderilir.</li>
		<li><code>HttpOnly</code> — Bu öznitelik ayarlanırsa, çerez client tarafı JavaScript aracılığıyla doğrudan erişilemez.</li>
	</ul>
	
	<p>Bu çerez özelliklerinin her biri uygulamanın güvenliğini etkileyebilir. Birincil etki, saldırganın uygulamanın diğer kullanıcılarını doğrudan hedef alabilmesidir.</p>

	<h2>Status Codes</h2>
	<p>Her HTTP response mesajı, ilk satırında isteğin sonucunu belirten bir durum kodu içermelidir. Durum kodları, kodun ilk rakamına göre beş gruba ayrılır:</p>
	
	<ul>
		<li><b>1xx</b> — Bilgilendirici.</li>
		<li><b>2xx</b> — İstek başarılı oldu.</li>
		<li><b>3xx</b> — Client farklı bir kaynağa yönlendirilir.</li>
		<li><b>4xx</b> — İstek bir çeşit hata içeriyor.</li>
		<li><b>5xx</b> — Sunucu, isteği yerine getirirken bir hatayla karşılaştı.</li>
	</ul>
	
	<p>Birçoğu yalnızca özel durumlarda kullanılan çok sayıda özel durum kodu vardır. İşte bir web uygulamasına saldırırken karşılaşma olasılığınızın en yüksek olduğu durum kodları ve bunlarla ilişkili olağan neden ifadeleri:</p>
	
	<ul>
		<li><code>100 Continue</code>, Client gövde içeren bir istek gönderdiğinde bazı durumlarda gönderilir. Response, istek başlıklarının alındığını ve istemcinin gövdeyi göndermeye devam etmesi gerektiğini belirtir. İstek tamamlandığında sunucu ikinci bir response döndürür.</li>
		<li><code>200 OK</code>, isteğin başarılı olduğunu ve response gövdesinin isteğin sonucunu içerdiğini gösterir</li>
		<li><code>201 Created</code>, isteğin başarılı olduğunu belirtmek için bir <code>PUT</code> isteğine yanıt olarak döndürülür.</li>
		<li><code>301 Moved Permanently</code>, tarayıcıyı kalıcı olarak <code>Location</code> başlığında belirtilen farklı bir URL'ye yönlendirir. Client gelecekte orijinal URL yerine yeni URL'yi kullanmalıdır.</li>
		<li><code>302 Found</code>, tarayıcıyı geçici olarak Location başlığında belirtilen farklı bir URL'ye yönlendirir. İstemci, sonraki isteklerde orijinal URL'ye geri dönmelidir.</li>
		<li><code>304 Not Modified</code>, tarayıcıya istenen kaynağın önbelleğe alınmış kopyasını kullanması talimatını verir. Sunucu, istemcinin kaynağın en son sürümüne sahip olup olmadığını belirlemek için <code>If-Modified-Since</code> ve <code>If-None-Match</code> istek başlıklarını kullanır.</li>
		<li><code>400 Bad Request</code>, istemcinin geçersiz bir HTTP isteği gönderdiğini gösterir. Muhtemelen, URL'ye bir boşluk karakteri yerleştirmek gibi bazı geçersiz yollarla bir isteği değiştirdiğinizde bu durumla karşılaşırsınız</li>
		<li><code>401 Unauthorized</code>, sunucunun isteğin kabul edilmesinden önce HTTP kimlik doğrulaması gerektirdiğini belirtir. <code>WWW-Authenticate</code> başlığı desteklenen kimlik doğrulama tür(ler)ine ilişkin ayrıntıları içerir.</li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
	</ul>
	


</body>
</html>


<!-- https://www.deepl.com/translator -->


































































