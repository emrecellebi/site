<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<link rel="stylesheet" type="text/css" href="css/doc.css">
	<title>Bölüm 2 - Temel Savunma Mekanizmaları</title>
</head>
<body>
	<h1>Temel Savunma Mekanizmaları</h1>
	<p>Web uygulamalarının temel güvenlik sorunu olan - tüm kullanıcı girişlerinin güvensiz olması - uygulamaların kendilerini saldırılara 
	karşı korumak için kullandığı bir dizi güvenlik mekanizmasını ortaya çıkarır. Hemen hemen tüm uygulamalar, kavramsal olarak benzer 
	olan mekanizmaları kullanırken, tasarımın detayları ve uygulamanın etkinliği büyük ölçüde değişmektedir.</p>
	
	<p>Web uygulamaları tarafından kullanılan savunma mekanizmaları aşağıdaki temel unsurlardan oluşur:</p>
	
	<ul>
		<li>Kullanıcıların yetkisiz erişimini engellemek için uygulamanın veri ve işlevlerine erişimi kontrol etme</li>
		<li>Kullanıcı girişlerini işlemek ve hatalı biçimlendirilmiş girişlerin istenmeyen davranışlara neden olmasını önlemek</li>
		<li>Saldırganları işlemek ve uygulamanın doğrudan hedef alındığında uygun savunma ve saldırı önlemleri alarak saldırıyı engellemek</li>
		<li>Uygulamayı yönetmek, yöneticilerin faaliyetlerini izlemelerine ve işlevselliğini yapılandırmalarına olanak tanımak</li>
	</ul>
	
	<p>Bu mekanizmalar, temel güvenlik sorununu ele alma konusundaki merkezi rolleri nedeniyle tipik bir uygulamanın saldırı yüzeyinin 
	büyük bir kısmını oluşturur. Düşmanınızı tanımanın savaşın ilk kuralı olduğu düşünülürse, bu mekanizmaları tam olarak anlamak, 
	uygulamalara etkili saldırı yapabilmenin temel ön koşuludur. Web uygulamalarını hacklemeye yeni başlıyorsanız (ve hatta başlamış 
	olsanız bile), karşılaştığınız her uygulamadaki bu temel mekanizmaların nasıl çalıştığını anlamaya zaman ayırmalı ve onları saldırılara 
	karşı savunmasız bırakan zayıf noktaları belirlemelisiniz.</p>
	
	<h2>Kullanıcı Erişimini Yönetme</h2>
	<p>Hemen hemen her uygulamanın karşılaması gereken merkezi bir güvenlik gereksinimi, kullanıcıların veri ve işlevlere erişimini kontrol 
	etmektir. Tipik bir durumda, anonim kullanıcılar, yetkilendirilmiş kullanıcılar ve yönetici kullanıcılar gibi farklı kullanıcı kategorileri 
	bulunur. Ayrıca, birçok durumda farklı kullanıcılara farklı veri kümesine erişim izin verilir. Örneğin, bir web posta uygulamasının 
	kullanıcıları kendi e-postalarını okuyabilmeli, ancak diğer insanların e-postalarına erişim izni verilmemelidir.</p>
	
	<p>Çoğu web uygulaması, erişimi üç ilişkili güvenlik mekanizmasıyla yönetir:</p>
	
	<ul>
		<li>(Authentication) Kimlik doğrulama</li>
		<li>(Session management) Oturum yönetimi</li>
		<li>(Access control) Erişim kontrolü</li>
	</ul>
	
	<p>Bu mekanizmaların her biri, bir uygulamanın saldırı yüzeyinin önemli bir alanını temsil eder ve genel güvenlik duruşunun temelini 
	oluşturur. Bu mekanizmalar arasındaki bağımlılıklar nedeniyle, mekanizmalar tarafından sağlanan toplam güvenlik, zincirin en zayıf 
	halkası kadar güçlü olur. Herhangi bir bileşenin hatalı olması, bir saldırganın uygulamanın işlevselliğine ve verilerine kısıtlama 
	olmaksızın erişebilmesine olanak tanıyabilir.</p>
	
	<h2>Kimlik doğrulama (Authentication)</h2>
	<p>Kimlik doğrulama mekanizması, bir uygulamanın kullanıcı erişimini ele almasında mantıksal olarak en temel bağımlılıktır. Bir 
	kullanıcının kimlik doğrulaması, kullanıcının iddia ettiği gibi gerçekten kim olduğunun belirlenmesini içerir. Bu özellik olmadan, 
	uygulama tüm kullanıcıları anonim olarak kabul etmek zorunda kalır - en düşük güven seviyesi.</p>
	
	<p>Çoğu web uygulaması, kullanıcının geçerlilik kontrolünü yapmak için kullanıcı adı ve şifre gönderdiği geleneksel kimlik 
	doğrulama modelini kullanır. Şekil 2-1, tipik bir giriş işlevini göstermektedir. Online bankalar tarafından kullanılan güvenlik 
	açısından kritik uygulamalarda, bu temel model genellikle ek kimlik bilgileri ve çoklu aşamalı bir giriş süreci ile desteklenir. 
	Güvenlik gereksinimleri daha da yüksek olduğunda, client sertifikalarına, akıllı kartlara dayalı 
	farklı kimlik doğrulama modelleri kullanılabilir. Kimlik doğrulama sürecinin yanı sıra, kimlik doğrulama mekanizmaları genellikle kayıt 
	olma, hesap kurtarma ve şifre değiştirme gibi diğer destekleyici işlevleri de içerir.</p>
	
	<center>
		<img src="img/2.1.png" alt="">
		<p><b>Şekil 2.1</b> Tipik bir giriş işlevi</p>
	</center>
	
	<p>Görünüşte basitliklerine rağmen, kimlik doğrulama mekanizmaları tasarım ve uygulama açısından geniş bir yelpazede hatalara sahiptir. 
	Ortak sorunlar, bir saldırganın diğer kullanıcıların kullanıcı adlarını belirlemesine, şifrelerini tahmin etmesine veya mantıksal 
	hataları istismar ederek giriş işlevini atlamasına olanak tanıyabilir. Bir web uygulamasını saldırırken, genellikle bu işlevlerdeki 
	çeşitli kimlik doğrulama ile ilgili hatalara büyük bir dikkat harcamalısınız. Şaşırtıcı bir şekilde, bu işlevlerdeki hatalar genellikle 
	yetkisiz erişim sağlamanıza ve hassas verilere ve işlevlere erişmenize olanak tanır.</p>
	
	<h2>Oturum yönetimi (Session Management)</h2>
	<p>Kullanıcı erişimini yönetme sürecindeki bir sonraki mantıklı görev, kimlik doğrulaması yapılmış kullanıcının oturumunu yönetmektir. 
	Kullanıcı başarılı bir şekilde uygulamaya giriş yaptıktan sonra tarayıcısından çeşitli sayfalara ve işlevlere erişir ve bir dizi HTTP 
	isteği yapar. Aynı zamanda, uygulama farklı kullanıcılardan gelen sayısız başka istekler alır, bazıları kimlik doğrulanmışken bazıları 
	anonimdir. Etkili erişim kontrolü sağlamak için, uygulamanın her benzersiz kullanıcıdan kaynaklanan istek serisini tanımlayıp işlemesi 
	gerekmektedir.</p>
	
	<p>Neredeyse tüm web uygulamaları, her kullanıcı için bir oturum oluşturarak ve kullanıcıya bir oturumu tanımlayan bir belirteç vererek bu 
	gereksinimi karşılar. Oturum kendisi, kullanıcının uygulamayla etkileşimi durumunu izleyen sunucuda tutulan bir dizi veri yapısıdır. 
	Belirteç ise, uygulamanın oturumu bu kullanıcıyla ilişkilendirmesini sağlayan benzersiz bir dizedir. Kullanıcı bir belirteç aldığında, 
	tarayıcı bunu her sonraki HTTP isteğinde otomatik olarak sunucuya gönderir, böylece uygulama isteği o kullanıcıyla ilişkilendirir. HTTP 
	çerezleri, oturum belirteçlerini iletmek için standart yöntemdir, ancak birçok uygulama bunun için gizli form alanları veya URL sorgu 
	dizgisi kullanır. Bir kullanıcı belirli bir süre boyunca istekte bulunmazsa, oturum ideal olarak sona erer, Şekil 2-2'de gösterildiği gibi.</p>
	
	<center>
		<img src="img/2.2.png" alt="">
		<p><b>Şekil 2.2</b> Bir oturumun zaman aşımını uygulayan uygulama</p>
	</center>
	
	<p>Saldırı yüzeyi açısından, oturum yönetimi mekanizması belirteçlerin güvenliğine son derece bağımlıdır. Bununla ilgili saldırıların çoğu, 
	diğer kullanıcılara verilen belirteçleri tehlikeye atmaya yöneliktir. Bu mümkün olduğunda, bir saldırgan kurban kullanıcı gibi taklit 
	yapabilir ve gerçekten o kullanıcı olarak oturum açmış gibi uygulamayı kullanabilir. Başlıca güvenlik açıkları, belirteçlerin nasıl 
	oluşturulduğunda ve sonrasında nasıl işlendiğinde ortaya çıkar ve saldırganın diğer kullanıcıların belirteçlerini ele geçirmesine olanak tanır.</p>
	
	<p>Birkaç uygulama, oturum belirteçlerine ihtiyaç duymadan kullanıcıları çoklu istekler arasında yeniden tanımlama için başka yöntemler 
	kullanır. Eğer HTTP'nin yerleşik kimlik doğrulama mekanizması kullanılıyorsa, tarayıcı her istekte kullanıcının kimlik bilgilerini 
	otomatik olarak tekrar gönderir, böylece uygulama kullanıcıyı doğrudan bunlardan tanımlayabilir. Diğer durumlarda, uygulama durum 
	bilgilerini sunucu yerine genellikle şifrelenmiş olarak client tarafında saklar, bu sayede müdahaleyi önler.</p>
	
	<h2>Erişim kontrolü (Access Control)</h2>
	<p>Kullanıcı erişiminin işlenmesi sürecindeki son mantıklı adım, her bir isteğin izin verilip verilmemesi gerektiği konusunda doğru kararlar 
	almak ve bunları uygulamaktır. Yukarıda açıklanan mekanizmalar doğru şekilde çalışıyorsa, uygulama her isteği kimden aldığını bilir. 
	Bu temelde, istenen eylemi veya veriye erişimi bu kullanıcının yapma yetkisine sahip olup olmadığına karar vermesi gerekmektedir, 
	Şekil 2-3'te gösterildiği gibi.</p>
	
	<p>Erişim kontrol mekanizması genellikle farklı alanlara ve işlev türlerine ilişkin farklı düşüncelerin dikkate alındığı ayrıntılı bir mantık 
	uygulamak zorundadır. Bir uygulama, özel yeteneklerin farklı kombinasyonlarını içeren çok sayıda kullanıcı rolünü destekleyebilir. 
	Bireysel kullanıcılara uygulama içindeki toplam verilerin bir alt kümesine erişim izni verilebilir. Belirli işlevler, işlem sınırlamalarını 
	ve diğer kontrolleri uygulayabilir ve bunların hepsi kullanıcının kimliğine dayalı olarak doğru şekilde uygulanmalıdır.</p>
	
	<p>Tipik erişim kontrol gereksinimlerinin karmaşık doğası nedeniyle, bu mekanizma, saldırganın yetkisiz erişim sağlamasına olanak tanıyan 
	güvenlik açıklarının sıkça kaynağıdır. Geliştiriciler genellikle kullanıcıların uygulama ile nasıl etkileşimde bulunacağına dair hatalı 
	varsayımlar yaparlar ve bazı uygulama işlevlerinden erişim kontrolü kontrollerini atlayarak gözden kaçırmalar yaparlar. Bu güvenlik 
	açıklarını araştırmak sıklıkla zahmetli olabilir, çünkü temel olarak aynı kontroller her işlev için tekrarlanmak zorundadır. Bununla 
	birlikte, erişim kontrol hatalarının yaygınlığı nedeniyle, bir web uygulamasına saldırdığınızda bu çaba her zaman yapılması 
	gereken bir yatırımdır.</p>
	
	<center>
		<img src="img/2.3.png" alt="">
		<p><b>Şekil 2.3</b> Erişim kontrolünü zorunlu kılan bir uygulama</p>
	</center>
	
	<h2>Kullanıcı Girişini İşleme</h2>
	<p>Birinci bölümde anlatılan temel güvenlik sorununu hatırlayalım: Tüm kullanıcı girdileri güvenilmezdir. Web uygulamalarına yönelik 
	birçok saldırı, beklenmeyen ve uygulamanın tasarımcıları tarafından amaçlanmayan davranışlara neden olacak şekilde düzenlenmiş 
	girdilerin gönderilmesini içerir. Bu nedenle, bir uygulamanın güvenlik savunmaları için önemli bir gereklilik, kullanıcı girdilerini 
	güvenli bir şekilde işlemesidir.</p>
	
	<p>Girişe dayalı zayıflıklar, bir uygulamanın işlevselliği içinde herhangi bir yerde ve yaygın olarak kullanılan neredeyse her tür 
	teknolojiyle ilgili olarak ortaya çıkabilir. "<em>Giriş doğrulama</em>" genellikle bu saldırılara karşı gerekli savunma olarak belirtilir. 
	Ancak, her yerde tek bir koruma mekanizması kullanılamaz ve kötü niyetli girişlere karşı korunmak her zaman kolay olmayabilir.</p>
	
	<h2>Input Çeşitleri</h2>
	<p>Tipik bir web uygulaması, kullanıcı tarafından sağlanan verileri birçok farklı biçimde işler. Ancak bazı giriş doğrulama yöntemleri, 
	tüm bu giriş biçimleri için uygun veya istenilen olmayabilir. Şekil 2-4, genellikle bir kullanıcı kayıt işlevi tarafından gerçekleştirilen 
	giriş doğrulamayı göstermektedir.</p>
	
	<center>
		<img src="img/2.4.png" alt="">
		<p><b>Şekil 2.4</b> Giriş doğrulama yapan bir uygulama</p>
	</center>
	
	<p>Birçok durumda, bir uygulama belirli bir giriş öğesi üzerinde çok katı doğrulama kontrolleri uygulayabilir. Örneğin, bir giriş işlevine 
	gönderilen bir kullanıcı adının en fazla sekiz karakter uzunluğunda olması ve yalnızca alfabetik karakterler içermesi istenebilir.</p>
	
	<p>Diğer durumlarda, uygulama daha geniş bir giriş aralığına katlanmak zorunda kalabilir. Örneğin, bir kişisel detaylar sayfasına gönderilen 
	bir adres alanı, mantıklı olarak harfler, rakamlar, boşluklar, tireler ve diğer karakterleri içerebilir. Ancak, bu öğe için 
	kısıtlamalar yine de uygulanabilir olmalıdır. Veri makul bir uzunluk sınırını (örneğin, 50 karakter) aşmamalı ve herhangi bir HTML 
	işaretlemesi içermemelidir.</p>
	
	<p>Bazı durumlarda, bir uygulama kullanıcılardan keyfi giriş kabul etmek zorunda kalabilir. Örneğin, bir blog uygulamasının kullanıcısı, 
	konusu web uygulaması hackleme olan bir blog oluşturabilir. Bloga yapılan gönderiler ve yorumlar, tartışılan açık saldırı dizelerini 
	içerebilir. Uygulama bu girişi bir veritabanına kaydetmeli, diske yazmalı ve kullanıcılara güvenli bir şekilde geri göstermelidir. 
	Kullanıcının gönderdiği girişi sadece potansiyel olarak kötü niyetli göründüğü için reddedemez, aksi halde uygulamanın bazı kullanıcılarına 
	büyük ölçüde değer kaybedebilir.</p>
	
	<p>Tarayıcı arayüzü kullanarak kullanıcıların girdiği çeşitli girişlerin yanı sıra, tipik bir uygulama sunucuda başlayan ve istemciye 
	gönderilen ve istemcinin sonraki isteklerde bunları sunucuya iletebilmesi için gereken birçok veri alır. Bu, kullanıcıların normalde 
	uygulamanın görmediği ancak bir saldırganın görüp değiştirebileceği çerezler ve gizli form alanları gibi öğeleri içerir. Bu durumlarda, 
	uygulamalar genellikle alınan verinin çok özel bir doğrulamasını yapabilir. Örneğin, bir parametrenin belirli bir küme bilinen değerden 
	birine sahip olması (örneğin, kullanıcının tercih ettiği dilin belirtilen bir çerez olması) veya belirli bir formatta olması (örneğin, 
	bir müşteri kimlik numarası) gerekebilir. Ayrıca, bir uygulama, sunucu tarafından oluşturulan verinin standart bir tarayıcıya sahip 
	sıradan bir kullanıcı tarafından mümkün olmayan şekilde değiştirildiğini tespit ettiğinde, bu genellikle kullanıcının uygulamayı 
	zayıflıklar için test etmeye çalıştığını gösterir. Bu durumlarda, uygulama isteği reddetmeli ve olası bir soruşturma için olayı 
	kaydetmelidir.</p>
	
	<h2>Input İşleme Yaklaşımları</h2>
	<p>Kullanıcı girişiyle ilgili sorunu çözmek için genellikle farklı genel yaklaşımlar benimsenir. Farklı yaklaşımlar 
	genellikle farklı durumlar ve farklı giriş türleri için tercih edilebilir ve bazen birleşik bir yaklaşım istenebilir.</p>
	
	<h2>Kötü Bilinenleri Reddet</h2>
	<p>Bu yaklaşım genellikle, saldırılarda kullanıldığı bilinen belirli dize veya desenleri içeren bir karaliste kullanır. 
	Doğrulama mekanizması, karalisteyle eşleşen herhangi bir veriyi engeller ve diğer tüm verilere izin verir.</p>
	
	<p>Genel olarak, bu, kullanıcı girişini doğrulamak için en az etkili yaklaşım olarak kabul edilir ve bunun iki temel nedeni vardır. 
	İlk olarak, bir web uygulamasındaki tipik bir güvenlik açığı, çeşitli şekillerde kodlanan veya temsil edilen geniş bir giriş yoluyla 
	sömürülebilir. Basit durumlar hariç, bir karaliste muhtemelen uygulamaya saldırmak için kullanılabilecek bazı giriş desenlerini 
	atlayacaktır. İkinci olarak, sömürü teknikleri sürekli olarak gelişmektedir. Var olan güvenlik açığı kategorilerini sömürme için yeni 
	yöntemler, mevcut karalisteler tarafından engellenmeyecektir.</p>
	
	<p>Birçok karaliste tabanlı filtre, engellenen girişin basit ayarlamalarıyla neredeyse utanç verici derecede kolay bir şekilde atlatılabilir. 
	Örneğin:</p>
	
	<ul>
		<li><code>SELECT</code> engellendiyse <code>SeLeCt</code> deneyin</li>
		<li><code>or 1=1--</code> engellendiyse <code>or 2=2--</code> deneyin</li>
		<li><code>or alert(‘xss’)</code> engellendiyse <code>prompt(‘xss’)</code> deneyin</li>
	</ul>
	
	<p>Diğer durumlarda, belirli anahtar kelimeleri engellemek için tasarlanan filtreler, uygulama tarafından yapılan parçalama 
	işlemini bozmak için ifadeler arasında standart olmayan karakterler kullanılarak atlatılabilir. Örneğin:</p>
	
	<blockquote>
		<code>
			<pre>
				SELECT/*foo*/username,password/*foo*/FROM/*foo*/users
				&lt;img%09onerror=alert(1) src=a&gt;
			</pre>
		</code>
	</blockquote>
	
	<p>Son olarak, birçok karaliste tabanlı filtre, özellikle web uygulama güvenlik duvarlarında uygulananlar, NULL bayt 
	saldırılarına karşı savunmasız olmuştur. Yönetilen ve yönetilmeyen yürütme bağlamlarında dizelerin nasıl işlendiği farklı 
	olduğu için, engellenmiş bir ifadenin önüne herhangi bir yerde bir NULL bayt eklemek, bazı filtrelerin girdiyi işlemeyi durdurmasına 
	ve dolayısıyla ifadeyi tanımlamamasına neden olabilir. Örneğin:</p>
	
	<blockquote>
		<code>
			<pre>
				SELECT/*foo*/username,password/*foo*/FROM/*foo*/users
				%00&lt;script&gt;alert(1)&lt;/script&gt;
			</pre>
		</code>
	</blockquote>
	
	<p><b>NOTE: NULL baytlarının işlenmesini istismar eden saldırılar, web uygulama güvenliği alanında birçok alanda ortaya çıkar. NULL baytının 
	bir dize ayırıcı olarak işlev gördüğü bağlamlarda, bir dosya adını veya bir back-end bileşenine yönelik bir sorguyu sonlandırmak 
	için kullanılabilir. NULL baytlarının hoş görüldüğü ve yok sayıldığı bağlamlarda (örneğin, bazı tarayıcılarda HTML içinde), 
	engellenen ifadelerin içine rasgele NULL baytları eklenerek bazı karaliste tabanlı filtrelerin etkisiz hale getirilmesi mümkündür.</b></p>
	
	<h2>Bilinenleri Kabul Et</h2>
	<p>Bu yaklaşım, yalnızca zararsız girdilerle eşleşen bir dizi belirli dize veya deseni veya kriterleri içeren bir beyaz liste kullanır. 
	Doğrulama mekanizması, beyaz listeye uyan verileri kabul eder ve diğer her şeyi engeller. Örneğin, bir uygulama, client tarafından 
	girilen bir ürün kodunu veritabanında aramadan önce yalnızca alfasayısal karakterler içerdiğini ve tam olarak altı karakter uzunluğunda 
	olduğunu doğrulayabilir. Ürün kodu üzerinde yapılacak sonraki işleme göre, geliştiriciler girişin bu testi geçmesi durumunda herhangi 
	bir soruna yol açamayacağını bilmektedir.</p>
	
	<p>Bu yaklaşım uygun olduğu durumlarda, potansiyel olarak kötü niyetli girişleri ele almanın en etkili yol olarak kabul edilir. 
	Beyaz liste oluşturulurken gerekli özen gösterildiğinde, bir saldırgan, manipüle edilmiş girişleri uygulamanın davranışını etkilemek 
	için kullanamaz. Bununla birlikte, bir uygulama, "iyi" olarak bilinen herhangi bir kriteri karşılamayan verileri işlemek zorunda 
	kalabileceği birçok durumda kabul etmek zorundadır. Örneğin, bazı insanların adlarında apostrof veya tire bulunabilir. Bunlar 
	veritabanlarına karşı saldırıda kullanılabilir, ancak uygulamanın gerçek adı altında kayıt yapmasına herkesin izin verilmesi 
	gerekebilir. Bu nedenle, beyaz liste tabanlı yaklaşım genellikle son derece etkilidir, ancak kullanıcı girişlerinin ele alınmasının 
	tüm amaçlı bir çözümü temsil etmez.</p>
	
	<h2>Sanitasyon</h2>
	<p>Bu yaklaşım, bazen güvenli olarak garanti edilemeyen verilerin kabul edilmesi gerektiğini kabul eder. Bu girişi reddetmek yerine, 
	uygulama veriyi farklı yollarla temizler ve olumsuz etkilere yol açmaması için önlem alır. Potansiyel olarak zararlı karakterler 
	veriden kaldırılabilir, yalnızca güvenli olduğu bilinenler bırakılır veya daha fazla işlem yapmadan önce uygun şekilde kodlanır 
	veya "kaçış" işlemine tabi tutulur.</p>
	
	<p>Veri temizleme üzerine kurulu yaklaşımlar genellikle son derece etkilidir ve birçok durumda kötü niyetli girişlerin genel bir 
	çözümü olarak güvenebilirsiniz. Örneğin, cross-site scripting saldırılarına karşı alınan yaygın savunma, tehlikeli karakterlerin 
	HTML kodlanarak uygulama sayfalarına gömülmeden önce kodlanmasıdır. Bununla birlikte, etkili bir temizleme işlemi, 
	potansiyel olarak zararlı verilerin bir giriş öğesinin içinde barındırılması gereken durumlarda zor olabilir. Bu durumda, daha sonra 
	açıklanacak olan bir sınır doğrulama yaklaşımı tercih edilir.</p>
	
	<h2>Güvenli Veri İşleme</h2>
	<p>Birçok web uygulaması açığı, kullanıcı tarafından sağlanan verinin güvensiz şekilde işlenmesinden kaynaklanır. Bu açıklar genellikle, 
	girişi doğrulayarak değil, üzerinde gerçekleştirilen işlemenin doğal olarak güvenli olduğunu sağlayarak önlenebilir. Bazı durumlarda, 
	yaygın sorunları önlemek için güvenli programlama yöntemleri kullanılabilir. Örneğin, SQL enjeksiyon saldırıları, veritabanı erişimi 
	için parametreli sorguların doğru şekilde kullanılmasıyla önlenebilir. Diğer durumlarda, uygulama işlevselliği, kullanıcı 
	girişinin bir işletim sistemi komut yorumlayıcısına iletilmesi gibi doğal olarak güvensiz uygulamalardan kaçınacak şekilde tasarlanabilir.</p>
	
	<p>Bu yaklaşım, web uygulamalarının gerçekleştirmesi gereken her türlü göreve uygulanamaz. Ancak kullanılabilir olduğu durumlarda, 
	potansiyel olarak zararlı girişlerle başa çıkmanın etkili bir genel yaklaşımıdır.</p>
	
	<h2>Semantik Kontroller</h2>
	<p>Şimdiye kadar anlatılan savunmalar, uygulamanın işleyişini engellemek için oluşturulmuş çeşitli şekillerde bozulmuş verilere karşı 
	korunmayı hedeflemektedir. Ancak, bazı güvenlik açıklarında, saldırgan tarafından sağlanan veri, sıradan, zararsız bir kullanıcının 
	gönderebileceği veriyle tamamen aynı olabilir. Onu zararlı yapan, onun gönderildiği farklı koşullardır. Örneğin, bir saldırgan, bir 
	gizli form alanında iletilen hesap numarasını değiştirerek başka bir kullanıcının banka hesabına erişmeye çalışabilir. Sözdizimsel 
	doğrulama bile kullanıcının verisi ile saldırganın verisi arasında ayrım yapamaz. Yetkisiz erişimi önlemek için uygulama, gönderilen 
	hesap numarasının onu gönderen kullanıcıya ait olduğunu doğrulamalıdır.</p>
	
	<h2>Sınır Doğrulama</h2>
	<p>Verilerin güven sınırları boyunca doğrulanması fikri tanıdık bir kavramdır. Web uygulamalarının temel güvenlik sorunu, kullanıcılardan 
	alınan verilerin güvenilmez olmasıdır. İstemci tarafında uygulanan giriş doğrulama kontrolleri performansı artırabilir ve kullanıcı 
	deneyimini iyileştirebilir, ancak aslında sunucuya ulaşan veriler hakkında herhangi bir güvence sağlamaz. Kullanıcı verilerinin sunucu 
	tarafındaki uygulama tarafından ilk alındığı nokta, büyük bir güven sınırını temsil eder. Bu noktada uygulama, kötü niyetli girişlere 
	karşı kendini koruma önlemleri almalıdır.</p>
	
	<p>Temel sorunun doğası gereği, giriş doğrulama sorununu internetin "kötü" ve güvensiz olduğu, sunucu tarafındaki uygulamanın ise "iyi" ve 
	güvenilir olduğu bir sınır olarak düşünmek cazip olabilir. Bu resimde, giriş doğrulamanın rolü, potansiyel olarak kötü niyetli verileri 
	temizlemek ve ardından temiz verileri güvenilir uygulamaya iletmektir. Bu noktadan itibaren veri güvenilir kabul edilebilir ve olası 
	saldırılara karşı başka bir kontrol veya endişe gerektirmez.</p>
	
	<p>Gerçek zayıflıkları incelemeye başladığımızda, giriş doğrulamanın bu basit resminin çeşitli nedenlerle yetersiz olduğu açıkça ortaya 
	çıkacaktır:</p>
	
	<ul>
		<li>Uygulamaların uyguladığı geniş işlev yelpazesi ve kullanılan farklı teknolojiler göz önüne alındığında, tipik bir uygulama kendisini 
		birçok çeşitli girişe dayalı saldırıya karşı savunmak zorundadır ve her bir saldırı çeşidi çeşitli şekilde oluşturulmuş veri kümelerini 
		kullanabilir. Tüm bu saldırılara karşı korunmak için harici sınırlarda tek bir mekanizma tasarlamak çok zor olurdu.</li>
		<li>Birçok uygulama fonksiyonu, farklı türde işlemleri birbirine zincirlemeyi içerir. Tek bir kullanıcı tarafından sağlanan giriş, farklı 
		bileşenlerde bir dizi işleme yol açabilir ve her birinin çıktısı bir sonraki giriş olarak kullanılabilir. Veri dönüştükçe, orijinal 
		girişle hiçbir benzerlik taşımayabilir. Usta bir saldırgan, kötü niyetli girişin işlemenin önemli bir aşamasında üretilmesine neden 
		olacak şekilde uygulamayı manipüle edebilir ve bu veriyi alan bileşeni hedef alan bir saldırı gerçekleştirebilir. Tüm kullanıcı 
		girişlerinin işlenmesi sonucunda ortaya çıkabilecek olası sonuçları önceden tahmin etmek için harici sınırlarda bir doğrulama mekanizması 
		uygulamak son derece zor olurdu.</li>
		<li>Farklı kategoriye sahip girişe dayalı saldırılara karşı savunma, birbirleriyle uyumsuz olan kullanıcı girişine farklı doğrulama kontrolleri 
		uygulamayı gerektirebilir. Örneğin, cross-site scripting saldırılarını önlemek için uygulamanın <code>></code> karakterini <code>&amp;gt;</code> şeklinde HTML kodlaması 
		gerekebilir ve komut enjeksiyon saldırılarını önlemek için uygulamanın <code>&</code> karakterini <code>;</code> içeren girişi engellemesi gerekebilir. Tüm saldırı 
		kategorilerini uygulamanın harici sınırında aynı anda önlemeye çalışmak bazen imkansız olabilir.</li>
	</ul>
	
	<p>Daha etkili bir model, sınırlama doğrulama (boundary validation) kavramını kullanır. Burada, sunucu tarafındaki her bir bileşen veya 
	işlevsel birim, girdilerini potansiyel olarak kötü niyetli bir kaynaktan geldiği şeklinde ele alır. Veri doğrulaması, bu güven 
	sınırlarında, istemci ve sunucu arasındaki harici sınıra ek olarak, her bir bileşende gerçekleştirilir. Bu model, yukarıda açıklanan 
	sorunlara çözüm sağlar. Her bileşen, karşılaşabileceği belirli tipte oluşturulmuş girdilere karşı kendini savunabilir. Veri, farklı 
	bileşenlerden geçerken, önceki dönüşümlerin sonucu olarak ne tür bir değere sahip olursa, doğrulama kontrolleri bu değere karşı yapılabilir. Ve 
	çeşitli doğrulama kontrolleri işleme farklı aşamalarda uygulandığından birbirleriyle çelişmezler.</p>
	
	<p>Şekil 2-5, sınırlama doğrulamanın kötü niyetli girişlere karşı korunmada en etkili yaklaşım olduğu tipik bir durumu göstermektedir. 
	Kullanıcı girişi, kullanıcı tarafından sağlanan girdi üzerinde birkaç işleme adımının gerçekleştirildiği ve her adımda uygun doğrulamanın 
	yapıldığı bir süreci içerir:</p>
	
	<ol>
		<li>Uygulama kullanıcının giriş bilgilerini alır. Form işleyicisi, her bir girdi öğesinin yalnızca izin verilen karakterleri içerdiğini, 
		belirli bir uzunluk sınırı içinde olduğunu ve herhangi bilinen saldırı imzalarını içermediğini doğrular.</li>
		<li>Uygulama kullanıcının kimlik bilgilerini doğrulamak için bir SQL sorgusu gerçekleştirir. SQL enjeksiyon saldırılarını önlemek için, 
		veritabanına saldırıda kullanılabilecek herhangi bir karakter, sorgu oluşturulmadan önce kaçırılır.</li>
		<li>Giriş başarılıysa, uygulama kullanıcının profiliyle ilgili bazı verileri SOAP hizmetine iletmek için kullanılır. SOAP enjeksiyon 
		saldırılarını önlemek için, kullanıcının profil verileri içindeki XML metakarakterler uygun şekilde kodlanır.</li>
		<li>Uygulama kullanıcının hesap bilgilerini tarayıcısına geri gösterir. Cross-site scripting saldırılarını önlemek için, uygulama dönen 
		sayfaya gömülü olan herhangi kullanıcı tarafından sağlanan veriyi HTML kodlar.</li>
	</ol>
	
	<center>
		<img src="img/2.5.png" alt="">
		<p><b>Şekil 2.5</b> Çoklu işleme aşamalarında sınırlama doğrulaması kullanan bir uygulama işlevi.</p>
	</center>
	
	<p>Bu senaryoda yer alan belirli zayıflıklar ve savunmalar daha sonra ayrıntılı olarak incelenecektir. Bu işlevselliğin varyasyonları, 
	verilerin daha ileri uygulama bileşenlerine iletilmesini gerektiriyorsa, ilgili güven sınırlarında benzer savunmaların uygulanması 
	gerekecektir. Örneğin, bir başarısız girişin uygulamanın kullanıcıya bir uyarı e-postası göndermesi durumunda, e-postaya dahil edilen 
	herhangi bir kullanıcı verisi SMTP enjeksiyon saldırılarına karşı kontrol edilmelidir.</p>
	
	<h2>Çok Adımlı Doğrulama ve Kanonikleştirme</h2>
	<p>Giriş işleme mekanizmalarının karşılaştığı yaygın bir sorun, kullanıcı tarafından sağlanan girişin doğrulama mantığı olarak birkaç 
	adımda manipüle edildiğinde ortaya çıkar. Bu süreç dikkatlice yönetilmezse, saldırgan, doğrulama mekanizması aracılığıyla kötü 
	niyetli verileri kaçırabilen özel olarak hazırlanmış bir giriş oluşturabilir. Bu sorunun bir versiyonu, bir uygulamanın belirli 
	karakterleri veya ifadeleri kaldırarak veya kodlayarak kullanıcı girişini temizlemeye çalıştığı durumlarda ortaya çıkar. Örneğin,
	bir uygulama, bazı cross-site scripting saldırılarına karşı korunmak için aşağıdaki ifadeyi kaldırmayı deneyebilir:</p>
	
	<code>
		&lt;script&gt;
	</code>
	
	<p>Herhangi bir kullanıcı tarafından sağlanan veriden. Bununla birlikte, bir saldırgan aşağıdaki girişi sağlayarak filtreyi atlayabilir:</p>
	
	<code>
		&lt;scr&lt;script&gt;ipt&gt;
	</code>
	
	<p>Engellenen ifade kaldırıldığında, çevreleyen veri kötü niyetli yükü geri getirmek için daralır, çünkü filtre rekürsif olarak uygulanmamaktadır.
	Benzer şekilde, kullanıcı girişine birden fazla doğrulama adımı uygulandığında, bir saldırgan filtrelemeyi atlamak için bu adımların 
	sıralamasını sömürebilir. Örneğin, uygulama önce ../recursively'u kaldırır ve ardından ..\recursively'u kaldırırsa, aşağıdaki giriş 
	doğrulamayı etkisiz hale getirmek için kullanılabilir:</p>
	
	<code>
		....\/
	</code>
	
	<p>Benzer bir sorun, verinin kanonikleştirilmesiyle ilgili olarak ortaya çıkar. Kullanıcının tarayıcısından gönderilen giriş, 
	çeşitli şekillerde kodlanmış olabilir. Bu kodlama şemaları, olağandışı karakterlerin ve ikili verilerin HTTP üzerinden güvenli 
	bir şekilde iletilmesini sağlar (daha fazla ayrıntı için Bölüm 3'e bakın). Kanonikleştirme, verilerin ortak bir karakter setine 
	dönüştürülmesi veya çözümlenmesi sürecidir. Giriş filtreleri uygulandıktan sonra herhangi bir kanonikleştirme yapılırsa, bir 
	saldırgan uygun bir kodlama şemasını kullanarak doğrulama mekanizmasını atlatabilir.</p>
	
	<p>Örneğin, bir uygulama bazı SQL enjeksiyon saldırılarına karşı korunmak için apostrof karakterini içeren girişi engellemeye çalışabilir. 
	Ancak, giriş daha sonra kanonikleştirilirse, bir saldırgan çift URL kodlamasını kullanarak filtreyi etkisiz hale getirebilir. Örneğin:</p>
	
	<code>%2527</code>
	
	<p>Bu giriş alındığında, uygulama sunucusu normal URL çözümlemesini yapar, böylece giriş şu şekilde olur:</p>
	
	<code>%27</code>
	
	<p>Bu bir apostrof içermez, bu yüzden uygulama filtrelerine izin verilir. Ancak uygulama bir sonraki URL çözümlemesini 
	gerçekleştirdiğinde, giriş bir apostrofa dönüştürülerek filtreyi atlatabilir.</p>
	
	<p>Eğer uygulama apostrofu kaldırır ve daha sonra başka bir kanonikleştirme yaparsa, aşağıdaki atlama etkili olabilir:</p>
	
	<code>%%2727</code>
	<p>Bu durumlardaki çoklu doğrulama ve kanonikleştirme adımlarının hepsinin uygulama sunucusu tarafında gerçekleşmesi 
	gerekmez. Örneğin, aşağıdaki girişte birkaç karakter HTML kodlanmıştır:</p>
	
	<code>&lt;iframe src=j&amp;#x61;vasc&amp;#x72ipt&amp;#x3a;alert&amp;#x28;1&amp;#x29; &gt;</code>
	
	<p>Eğer sunucu tarafında uygulama, belirli JavaScript ifadelerini ve karakterleri engellemek için bir giriş filtresi kullanıyorsa, 
	kodlanmış giriş filtreleri atlayabilir. Ancak, eğer giriş daha sonra uygulamanın yanıtına kopyalanıyorsa, bazı tarayıcılar <code>src</code> 
	parametresi değerini HTML çözümlemesi yapar ve gömülü JavaScript çalıştırılır.</p>
	
	<p>Web uygulamalarında kullanılmak üzere tasarlanmış olan standart kodlama şemalarının yanı sıra, kanonikleştirme sorunları, 
	uygulama tarafından kullanılan bir bileşenin veriyi bir karakter setinden başka bir karakter setine dönüştürdüğü diğer 
	durumlarda da ortaya çıkabilir. Örneğin, bazı teknolojiler, basılı sembollerindeki benzerliklere dayanarak karakterleri "en iyi eşleme" 
	prensibiyle dönüştürebilir. Burada, <code>«</code> ve <code>»</code> karakteri <code>&lt;</code> karakteri ise <code>&gt;</code> dönüştürülebilir ve Ÿ karakteri Y'ye, Â karakteri 
	ise A'ya dönüştürülebilir. Bu davranış, bir uygulamanın giriş filtrelerinin engellediği karakterleri veya anahtar kelimeleri 
	kaçırabilmek için sıklıkla kullanılabilir.</p>
	
	<p>Bu kitap boyunca, yaygın giriş temelli güvenlik açıklarına karşı birçok uygulamanın savunmalarını atlatabilen birçok bu tür 
	saldırıyı açıklayacağız.</p>
	
	<p>Çok adımlı doğrulama ve kanonikleştirme sorunlarından kaçınmak bazen zor olabilir ve tek bir çözüm yoktur. Bir yaklaşım, temizleme 
	adımlarını tekrarlayarak, bir giriş öğesinde başka bir değişiklik yapılmadığı sürece devam etmektir. Ancak, istenen temizleme 
	sorunlu bir karakteri kaçmasına neden oluyorsa, bu sonsuz bir döngüye yol açabilir. Genellikle, sorunu yalnızca duruma göre, 
	gerçekleştirilen doğrulama türlerine dayanarak ele almak mümkündür. Mümkün olduğunda, bazı türdeki hatalı girişleri temizlemeye 
	çalışmak yerine tamamen reddetmek tercih edilebilir.</p>
	
	<h2>Saldırganlarla Başa Çıkmak</h2>
	<p>Güvenliği önemli olan herhangi bir uygulama tasarlayan kişi, doğrudan hedef alınacağını ve yetenekli saldırganlar tarafından 
	saldırılara maruz kalacağını varsaymalıdır. Uygulamanın güvenlik mekanizmalarının temel bir işlevi, bu saldırılara kontrollü 
	bir şekilde yanıt verebilmektir. Bu mekanizmalar genellikle saldırganı mümkün olduğunca engellemek ve uygulamanın sahiplerine 
	ne olduğuna dair uygun bildirimler ve kanıtlar sunmak amacıyla savunma ve saldırı önlemlerini bir araya getirir. Saldırganlarla 
	başa çıkmak için uygulanan önlemler genellikle şu görevleri içerir:</p>
	
	<ul>
		<li>Hataların yönetimi</li>
		<li>Denetim kayıtlarının tutulması</li>
		<li>Yöneticilere bildirimlerin yapılması</li>
		<li>Saldırılara yanıt verme</li>
	</ul>
	
	<h2>İşleme Hataları</h2>
	<p>Kullanıcı girişlerini doğrularken uygulama geliştiricilerinin ne kadar dikkatli olursa olsun, bazı beklenmeyen hataların meydana 
	gelmesi neredeyse kaçınılmazdır. Normal kullanıcıların eylemlerinden kaynaklanan hatalar genellikle işlevsellik ve kullanıcı kabul 
	testleri sırasında tespit edilir. Bu nedenle, üretim ortamında uygulama dağıtılmadan önce bu hatalar dikkate alınır. Ancak, kötü 
	niyetli bir kullanıcının uygulama ile etkileşime geçebileceği her olası yolun önceden tahmin edilmesi zordur, bu yüzden uygulama 
	saldırı altına girdiğinde beklenmeyen hataların ortaya çıkması muhtemeldir.</p>
	
	<p>Ana bir savunma mekanizması, uygulamanın beklenmeyen hataları düzgün bir şekilde işlemesidir veya bu hatalardan kurtulur ya da 
	kullanıcıya uygun bir hata mesajı sunar. Bir üretim ortamında, uygulama hiçbir şekilde yanıtlarında sistem tarafından oluşturulan 
	mesajları veya hata ayıklama bilgilerini döndürmemelidir. Bu kitap boyunca göreceğiniz gibi, aşırı ayrıntılı hata mesajları, kötü 
	niyetli kullanıcılara uygulamaya karşı saldırılarını ilerletmelerinde büyük yardımcı olabilir. Bazı durumlarda, saldırgan, hatalı 
	hata işleme yöntemini kullanarak hata mesajlarında kendilerine duyarlı bilgileri alabilir ve bu da uygulamadan veri çalmak için 
	değerli bir kanal sağlar. Şekil 2-6, işlenmemiş bir hatanın ayrıntılı bir hata mesajına yol açtığı bir örneği göstermektedir.</p>
	
	<p>Çoğu web geliştirme dili, try-catch blokları ve doğrulanan istisnalar aracılığıyla iyi bir hata işleme desteği sağlar. Uygulama kodu, 
	belirli ve genel hataları yakalamak ve bunları uygun şekilde işlemek için bu yapıları yaygın olarak kullanmalıdır. Ayrıca, çoğu uygulama 
	sunucusu, işlenmemiş uygulama hatalarıyla özelleştirilmiş şekillerde başa çıkmak için yapılandırılabilir, örneğin bilgilendirici olmayan
	bir hata mesajı sunarak. Bu önlemlerle ilgili daha fazla ayrıntı için Bölüm 15'e bakın.</p>
	
	<center>
		<img src="img/2.6.png" alt="">
		<p><b>Şekil 2.6</b> İşlenmemiş bir hata</p>
	</center>
	
	<p>Etkili hata işleme genellikle uygulamanın günlükleme mekanizmalarıyla entegre edilir ve beklenmeyen hatalar hakkında mümkün olduğunca 
	çok hata ayıklama bilgisi kaydedilir. Beklenmeyen hatalar genellikle uygulamanın savunmalarındaki kusurlara işaret eder ve uygulama 
	sahibinin gereken bilgilere sahipse bunlar kaynağında ele alınabilir.</p>

	<h2>Denetim Günlüklerini Tutma</h2>
	<p>Audit loglar, bir uygulamaya yönelik sızma girişimlerini araştırırken öncelikle değerlidir. Bu tür bir olayın ardından,
	etkili bir denetim günlüğü uygulama sahiplerinin tam olarak ne olduğunu anlamalarını, hangi güvenlik açıklarının (varsa) 
	sömürüldüğünü, saldırganın yetkisiz erişim sağlayıp sağlamadığını veya yetkisiz eylemler gerçekleştirip gerçekleştirmediğini 
	ve mümkün olduğunca saldırganın kimliğine dair kanıt sağlamalarını sağlamalıdır.</p>
	
	<p>Güvenliğin önemli olduğu herhangi bir uygulamada, temel olaylar varsayılan olarak günlüklenmelidir. En azından genellikle 
	aşağıdakileri içerir:</p>
	
	<ul>
		<li>Başarılı ve başarısız oturum açma ile şifre değişikliği gibi kimlik doğrulama işlevi ile ilgili tüm olaylar</li>
		<li>Kredi kartı ödemeleri ve fon transferleri gibi önemli işlemler</li>
		<li>Erişim kontrol mekanizmaları tarafından engellenen erişim girişimleri</li>
		<li>Aşikar kötü niyetli niyetleri gösteren bilinen saldırı dizelerini içeren talepler herhangi birinin kaydedilmesi</li>
	</ul>
	
	<p>Birçok güvenlik açısından kritik uygulamada, örneğin online bankalar tarafından kullanılan uygulamalarda, her istemci talebi 
	tam olarak kaydedilir ve herhangi bir olayı araştırmak için kullanılabilecek tam bir adli kayıt sağlanır.</p>
	
	<p>Etkili denetim günlükleri genellikle her olayın zamanını, talebin alındığı IP adresini ve kullanıcının hesabını (eğer kimlik 
	doğrulanmışsa) kaydeder. Bu tür günlükler yetkisiz okuma veya yazma erişimine karşı güçlü bir şekilde korunmalıdır. Etkili bir 
	yaklaşım, denetim günlüklerini yalnızca ana uygulamadan güncelleme mesajlarını kabul eden bağımsız bir sistemde saklamaktır. Bazı 
	durumlarda, günlüklerin bütünlüğünü sağlamak için yazma işlemi yapılamayan ortamlara kaydedilebilirler.</p>
	
	<p>Saldırı yüzeyi açısından, kötü korunan denetim günlükleri, saldırganlar için önemli bilgiler sağlayabilir ve oturum belirteçleri ve 
	istek parametreleri gibi bir dizi hassas bilgiyi ortaya çıkarabilir. Bu bilgiler, saldırganın hemen tüm uygulamayı ele geçirmesine 
	olanak sağlayabilir, Şekil 2-7'de gösterildiği gibi.</p>
	
	<center>
		<img src="img/2.7.png" alt="">
		<p><b>Şekil 2.7</b> Diğer kullanıcılar tarafından gönderilen hassas bilgileri içeren kötü korunan uygulama günlükleri</p>
	</center>
	
	<h2>Uyarı Yöneticileri</h2>
	<p>Denetim günlükleri, bir uygulamanın sahiplerinin saldırı girişimlerini geriye dönük olarak araştırmasına ve mümkünse fail hakkında 
	yasal işlem başlatmasına olanak tanır. Bununla birlikte, birçok durumda, saldırılara anlık olarak, gerçek zamanlı olarak yanıt vermek 
	çok daha hızlı bir eylem yapılmasını gerektirir. Örneğin, yöneticiler saldırganın kullandığı IP adresini veya kullanıcı hesabını 
	engelleyebilir. Aşırı durumlarda, saldırıyı araştırırken ve önleyici önlemler alırken uygulamayı hatta çevirebilirler. Hatta başarılı 
	bir sızma gerçekleşmiş olsa bile, erken aşamada savunma önlemleri alınması durumunda etkileri hafifletilebilir.</p>
	
	<p>Çoğu durumda, uyarı mekanizmaları, her gerçek saldırıyı güvenilir bir şekilde bildirmenin ve bu kadar çok uyarı üretilmemesiyle göz 
	ardı edilmesinin çelişen hedeflerini dengelemelidir. İyi tasarlanmış bir uyarı mekanizması, kararlı bir saldırının gerçekleştiğini 
	teşhis etmek için çeşitli faktörleri kullanabilir ve mümkünse ilgili olayları tek bir uyarıda toplayabilir. Uyarı mekanizmaları 
	tarafından izlenen anormal olaylar genellikle şunları içerir:</p>
	
	<ul>
		<li>Bir IP adresinden veya kullanıcıdan alınan çok sayıda istek gibi kullanım anormallikleri, otomatize bir saldırıyı gösterir.</li>
		<li>Tek bir banka hesabına yapılan veya bu hesaptan yapılan olağandışı sayıda fon transferi gibi iş anormallikleri.</li>
		<li>Bilinen saldırı karakter dizilerini içeren istekler.</li>
		<li>Normal kullanıcılardan gizlenen verilerin değiştirildiği istekler.</li>
	</ul>
	
	<p>Bazı bu işlevler, genelde hazır uygulama güvenlik duvarları ve sızma tespit ürünleri tarafından oldukça iyi bir şekilde sağlanabilir. 
	Bu ürünler genellikle imza tabanlı ve anomalili kuralların bir karışımını kullanarak uygulamanın kötüye kullanılmasını tespit etmeye 
	ve reaktif olarak kötü niyetli istekleri engellemeye ve yöneticilere uyarılar göndermeye yarar. Bu ürünler, kaynakların hemen 
	düzeltilmediği bilinen var olan uygulamaların korunmasında değerli bir savunma katmanı oluşturabilir. Bununla birlikte, etkinlikleri 
	genellikle her web uygulamasının farklı olması nedeniyle sınırlı olabilir, bu yüzden kullanılan kurallar nispeten genel niteliktedir. 
	Web uygulama güvenlik duvarları, saldırganın her istek parametresinde standart saldırı dizelerini gönderdiği en açık saldırıları tespit 
	etme konusunda başarılı olurlar. Ancak, birçok saldırı daha karmaşıktır. Örneğin, saldırgan başka bir kullanıcının verilerine erişmek 
	için gizli bir alanda hesap numarasını değiştirir veya uygulamanın mantığında hataları sömürmek için sıralama dışı istekler gönderir. 
	Bu durumlarda, saldırgan tarafından gönderilen istek, masum bir kullanıcı tarafından gönderilenle aynı olabilir. Onu kötü niyetli yapan 
	şey, isteğin yapıldığı koşullardır.</p>
	
	<p>Herhangi bir güvenlik-kritik uygulamada, gerçek zamanlı uyarıları etkin bir şekilde uygulamanın giriş doğrulama mekanizmaları ve diğer
	kontrollerle sıkı bir şekilde entegre etmek en etkili yoldur. Örneğin, bir çerezin belirli bir değer kümesine sahip olması bekleniyorsa, 
	bunun ihlal edilmesi, değerin uygulamanın normal kullanıcıları tarafından mümkün olmayan bir şekilde değiştirildiğini gösterir. Benzer 
	şekilde, bir kullanıcı bir gizli alandaki hesap numarasını değiştirerek başka bir kullanıcının hesabını tanımlarsa, bu kesinlikle kötü 
	niyetli bir niyeti işaret eder. Uygulama zaten bu saldırıları, birincil savunmalarının bir parçası olarak kontrol ediyor olmalı ve bu 
	koruyucu mekanizmalar kolayca uygulamanın uyarı mekanizmasına bağlanarak tamamen özelleştirilmiş kötü niyetli etkinlik göstergeleri 
	sağlayabilir. Bu kontrol mekanizmaları, uygulamanın gerçek mantığına uygun bir şekilde özelleştirildiği için, hazır çözümlere göre 
	yanlış pozitiflere çok daha az eğilimlidir</p>
	
	<h2>Saldırılara Tepki Vermek</h2>
	<p>Yöneticilere uyarı göndermenin yanı sıra, birçok güvenlik-kritik uygulama, potansiyel olarak kötü niyetli belirlenen 
	kullanıcılara karşı savunma amacıyla dahili mekanizmalara sahiptir.</p>
	
	<p>Her uygulamanın farklı olması nedeniyle, gerçek dünyada yapılan saldırıların çoğu, saldırganın sistematik olarak zayıf noktaları 
	araştırması gerektirir ve çeşitli yaygın zayıflıkların varlığını göstermeyi amaçlayan özel olarak hazırlanmış girdiler içeren çok 
	sayıda istek gönderir. Etkili giriş doğrulama mekanizmaları, bu isteklerin birçoğunu potansiyel olarak kötü niyetli tanımlayacak 
	ve girişin uygulamaya istenmeyen bir etkisi olmasını engelleyecektir. Ancak, bu filtreleri atlayacak bazı yöntemlerin mevcut olduğunu 
	ve uygulamanın keşfedilip sömürülecek gerçek zayıflıklar içerdiğini varsaymak mantıklıdır. Sistematik bir şekilde çalışan bir 
	saldırganın bu hataları keşfetmesi muhtemeldir.</p>
	
	<p>Bu nedenle, bazı uygulamalar, bu şekilde çalışan bir saldırgana karşı otomatik reaktif önlemler alır. Örneğin, saldırganın 
	isteklerine giderek daha yavaş yanıt verebilir veya saldırganın oturumunu sonlandırarak saldırıyı sürdürmeden önce giriş yapmasını 
	veya diğer adımları tamamlamasını gerektirebilir. Bu önlemler, en sabırlı ve kararlı saldırgana karşı etkili olmasa da, daha rastgele 
	saldırganları caydıracak ve yöneticilerin durumu izlemek ve gerektiğinde daha drastik önlemler almak için ek süre kazandıracaktır.</p>
	
	<p>Saldırganlara karşı tepki vermek, elbette uygulamadaki var olan zayıflıkları düzeltmenin yerine geçmez. Ancak, gerçek dünyada, en özenli 
	çabalara rağmen bir uygulamayı güvenlik açıklarından arındırmak bazı sömürülebilir hataların kalmasına neden olabilir. Bir saldırgana 
	karşı daha fazla engel koymak, mevcut zayıflıkların keşfedilme ve sömürülme olasılığını azaltan etkili bir savunma önlemidir.</p>
	
	<h2>Uygulamayı Yönetme</h2>
	<p>Herhangi bir yararlı uygulama yönetilmeli ve idare edilmelidir. Bu özellik genellikle uygulamanın güvenlik mekanizmalarının 
	önemli bir parçasını oluşturur. Yöneticilerin kullanıcı hesaplarını ve rollerini yönetmelerine, erişim izleme ve denetim 
	işlevlerini gerçekleştirmelerine, teşhis görevlerini yapmalarına ve uygulamanın işlevselliğinin bazı yönlerini yapılandırmalarına 
	olanak sağlar.</p>
	
	<p>Birçok uygulamada, yönetici işlevleri uygulamanın kendisi içinde uygulanır ve çekirdek işlevselliğiyle aynı web arayüzü üzerinden 
	erişilebilir, Şekil 2-8'de gösterildiği gibi. Bu durumda, yönetim mekanizması uygulamanın saldırı yüzeyinin kritik bir parçasını 
	temsil eder. Saldırgan için temel cazibesi, ayrıcalık yükseltme için bir araç olarak hizmet etmesidir. Örneğin:</p>
	
	<ul>
		<li>Kimlik doğrulama mekanizmasındaki zayıflıklar, saldırganın yönetici erişimi elde etmesini sağlayabilir ve etkili bir şekilde tüm 
		uygulamanın güvenliğini tehlikeye atabilir.</li>
		<li>Birçok uygulama, yönetici işlevlerinin bazılarına etkili bir erişim kontrolü uygulamaz. Bir saldırgan, güçlü ayrıcalıklara sahip yeni 
		bir kullanıcı hesabı oluşturma yöntemi bulabilir.</li>
		<li>Yönetici işlevselliği genellikle sıradan kullanıcılardan kaynaklanan verileri görüntülemeyi içerir. Yönetim arayüzünde mevcut olan 
		herhangi bir cross-site scripting hatası, güçlü ayrıcalıklara sahip bir kullanıcı oturumunun tehlikeye girmesine yol açabilir.</li>
		<li>Yönetici işlevselliği, kullanıcıların güvenilir kabul edildiği veya penetrasyon testçilerinin sadece düşük ayrıcalıklı hesaplara erişim 
		sağlandığı için daha az sıkı bir güvenlik testine tabi tutulur. Dahası, işlevsellik genellikle doğası gereği tehlikeli işlemleri 
		gerçekleştirmek için diskteki dosyalara veya işletim sistemi komutlarına erişim gerektirir. Bir saldırgan yönetim işlevini tehlikeye 
		atabilirse, genellikle tüm sunucuyu ele geçirmek için bunu kullanabilir.</li>
	</ul>
	
	<center>
		<img src="img/2.8.png" alt="">
		<p><b>Şekil 2.8</b> Bir web uygulaması içinde bir yönetim arayüzü</p>
	</center>
	
	<h2>Özet</h2>
	<p>Neredeyse tüm web uygulamaları arasındaki kapsamlı farklara rağmen, hemen hemen tüm web uygulamaları aynı temel güvenlik 
	mekanizmalarını bir şekilde kullanır. Bu mekanizmalar, kötü niyetli kullanıcılara karşı uygulamanın temel savunmalarını 
	oluşturur ve dolayısıyla uygulamanın saldırı yüzeyinin büyük bir bölümünü oluşturur. Bu kitapta daha sonra inceleyeceğimiz 
	zayıflıklar çoğunlukla bu temel mekanizmaların içindeki hatalardan kaynaklanmaktadır.</p>
	
	<p>Bu bileşenler arasında, kullanıcı erişimi ve kullanıcı girişi işleme mekanizmaları en önemli olanlarıdır ve bir uygulamaya saldırı 
	düzenlerken büyük bir dikkat gerektirir. Bu mekanizmalardaki hatalar genellikle uygulamanın tamamen ele geçirilmesine yol açar, 
	böylece başka kullanıcılara ait verilere erişebilir, yetkisiz işlemler gerçekleştirebilir ve keyfi kod ve komutlar enjekte edebilirsiniz.</p>
	
</body>
</html>